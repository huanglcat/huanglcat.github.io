<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[WebPack基础配置详解]]></title>
    <url>%2F2019%2F05%2F21%2Fwebpack-base%2F</url>
    <content type="text"><![CDATA[WebPack是什么定义：WebPack是模块打包工具。原理：分析项目结构，找到JavaScript模块以及其他浏览器不能直接运行的模块（Scss，TypeScript等），转换并打包为浏览器可以识别并运行的格式，让浏览器使用。 工作流程：1、通过配置找到给定的入口文件（如index.js）2、从入口文件开始分析并处理项目所有的依赖模块，并递归地构建一个依赖关系图（dependency graph）。webpack把所有的文件都当做模块。 * JavaScript模块：webpack自己本身就可以识别并处理 * 其他模块：通过使用loaders来分析和转译浏览器不认识的模块为浏览器认识的格式 3、把所有的模块打包为一个或多个浏览器可识别的JavaScript文件，默认叫做bundle.js（也可以自己改名），根据给定的输出地址，输出到指定目录，一般叫做dist。webpack是基于node的，所以把静态文件都看成模块，通过模块化语言（esmodule,commonjs,require语法）识别模块的引入，当遇到模块引入时，webpack就知道这是一个依赖模块了。 官网链接：英：https://webpack.js.org/ 【较新，webpack相关更新都会比较及时】中：https://www.webpackjs.com/ WebPack使用下面通过一系列详细实例来解析webpack配置。 安装新建目录，在目录下执行命令：123npm init -y #初始化一个package.jsonnpm install webpack webpack-cli -D #本地安装最新版`webpack`,`webpack-cli`npm info webpack #查看webpack历史版本信息（当要安装特定版本时） webpack打包Js模块由于最新版的webpack是支持零配置，默认的入口文件是src/index.js，因此我们新建一个src文件夹，新建两个js文件，一个默认的入口文件index.js，一个a.js：123//index.jsimport a from &quot;./a&quot;a() 12345//a.jsfunction a()&#123; console.log(&quot;hello,我是a&quot;);&#125; export default a; 新建一个index.html:123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;./src/index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 目录现在如下：这时候打开在浏览器打开html，浏览器是不识别import的，会报错，因此我们使用webpack来解析并打包js模块，运行命令：12345678910111213141516171819F:\front-end\webpack\webpack-demos&gt;npx webpacknpx: 1 安装成功，用时 4.878 秒&apos;prefix&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。Hash: b14a40261c3e17ea5995Version: webpack 4.31.0Time: 355msBuilt at: 2019-05-19 15:42:16 Asset Size Chunks Chunk Namesmain.js 976 bytes 0 [emitted] mainEntrypoint main = main.js[0] ./src/index.js + 1 modules 97 bytes &#123;0&#125; [built] | ./src/index.js 24 bytes [built] | ./src/a.js 73 bytes [built]WARNING in configurationThe &apos;mode&apos; option has not been set, webpack will fallback to &apos;production&apos; for this value. Set&apos;mode&apos; option to &apos;development&apos; or &apos;production&apos; to enable defaults for each environment.You can also set it to &apos;none&apos; to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/ webpack命令行打包的命令：123&gt;webpack #打包，默认入口文件为src/index.js&gt;webpack index.js #打包，指定入口文件路径&gt; 可以看到webpack把js模块打包了并输出了一个main.js，现在目录下多了一个dist文件夹：把index.html里引入的js路径修改为dist/main.js，在浏览器打开，就可以看到js正确执行结果：在运行npx webpack时，我们可以看到有一个警告：1234WARNING in configurationThe &apos;mode&apos; option has not been set, webpack will fallback to &apos;production&apos; for this value. Set&apos;mode&apos; option to &apos;development&apos; or &apos;production&apos; to enable defaults for each environment.You can also set it to &apos;none&apos; to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/ 意思是说我们没有设置mode选项，这是webpack的打包模式，默认是“production”就是生产打包选项，production模式会自自动压缩打包后的文件，我们可以把mode设置为其他模式，设置为开发模式（development）：1234const path = require(&apos;path&apos;);module.exports = &#123; mode:&quot;development&quot;&#125; 再次运行时，可以看到输出的文件不再是压缩后的文件。 webpack配置文件零配置比较局限，要有更多的功能需要手动配置，根目录下新增一个webpack.config.js：1234//webpack.config.js//是一个对象module.exports = &#123;&#125; 为什么要是webpack.config.js呢，这是webpack定义的一个默认的配置文件名，webpack运行时会检查是否有这个配置文件，有这个配置文件时，会使用其中的配置来覆盖默认配置。 entry &amp; output入口和输出文件目录是可以自己设定的，输入以下内容：12345678910111213//webpack.config.jsconst path = require(&apos;path&apos;);module.exports = &#123; //entry:&quot;./src/index.js&quot;, #入口文件路径配置 entry:&#123; #入口文件配置可以使用字符串模式也可以使用对象模式 main:&apos;./src/index.js&apos; &#125;, output:&#123; #输出文件路径配置 filename:&apos;bundle.js&apos;, #输出文件名 //output的path需要是绝对路径 path:path.resolve(__dirname,&apos;dist&apos;) #输出文件路径，绝对路径，使用node.js的path模块来解析为绝对路径，这里设置为根目录下的dist目录 &#125;,&#125; 这里修改了出口文件的名字，删除dist文件夹后，再次运行npx webpack，可以看到dist里的文件已经变成了bundle.js 什么是loader上面已经说到，webpack默认只能识别JS模块，其他模块是不识别的。而loader就是帮助webpack来识别并解析除了JS的其他模块的。针对各种各样的模块，有各种的loader。loader是一个声明式函数。当webpack中有不是JS的模块时，需要配置对应的loader，监测对应的模块格式，使用对应的loader处理。loader的配置主要在module.rules中进行，这是一个数组，里面是各种loader的规则。每一个loader的主要工作机制： 识别文件类型，确定具体处理该模块的loader（rule.test） 使用对应的loader，对文件进行相关操作转换（rule.use）loader的在配置文件中的设置：123456789101112131415161718192021222324//webpack.config.jsconst path = require(&apos;path&apos;);module.exports = &#123; entry:&#123; main:&apos;./src/index.js&apos; &#125;, output:&#123; filename:&apos;bundle.js&apos;, path:path.resolve(__dirname,&apos;dist&apos;) &#125;, //不认识的模块（不是js)的配置 module:&#123; rules:[ &#123; test:/\.xxx$/, //表示匹配规则，是一个正则表达式 use:&#123; //表示针对匹配文件将使用处理的loader loader:&quot;xxx-loader&quot;, options:&#123; //loader的可配置项 &#125; &#125; &#125; ] &#125;,&#125; 常用的loader列举： 处理静态文件：file-loader、url-loader、raw-loader 处理样式模块：style-loader、css-loader、sass-loader、less-loader、postcss-loader 处理数据文件：csv-loader、xml-loader 处理模块语言：html-loader、markdown-loader 处理测试模块：mocha-loader、eslint-loader静态资源模块loader：file-loader静态资源，比如图片、文件，使用file-loader来处理 file-loader的工作机制： 把打包入口中识别出来的静态模块直接复制到输出目录（dist）下； 返回一个复制的文件的地址名称（文件名） 使用场景：只需要把文件移动到输出目录下，不需要处理，比如图片、excel、word、svg等等。在index.js中引入一个图片，图片是静态文件，webpack是不认识的，需要file-loader处理 1234import a from &quot;./a&quot;a()var pic = require(&apos;./pic.jpg&apos;);console.log(pic); 先安装：1npm i file-loader -D 配置：123456789101112131415161718192021222324const path = require(&apos;path&apos;);module.exports = &#123; entry:&quot;./src/index.js&quot;, // entry:&#123; // main:&apos;./index.js&apos; // &#125;, output:&#123; filename:&apos;bundle.js&apos;, //绝对路径 path:path.resolve(__dirname,&apos;dist&apos;) &#125;, mode:&quot;development&quot;, //不认识的模块（不是js)的配置 module:&#123; rules:[ &#123; test:/\.(jpe?g|png|gif)$/, use:&#123; loader:&quot;file-loader&quot; &#125; &#125; ] &#125;,&#125; 执行npx webpack可以看到文件正常打包，dist里面多了一个图片：123456789101112131415F:\front-end\webpack\webpack-demos&gt;npx webpacknpx: 1 安装成功，用时 4.322 秒&apos;prefix&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。Hash: 2ef4598423ef35d9401bVersion: webpack 4.31.0Time: 409msBuilt at: 2019-05-19 21:43:02 Asset Size Chunks Chunk Names91d98190304e9e52a3b55d37b5f60397.jpg 8.89 KiB [emitted] bundle.js 4.86 KiB main [emitted] mainEntrypoint main = bundle.js[./src/a.js] 73 bytes &#123;main&#125; [built][./src/index.js] 59 bytes &#123;main&#125; [built][./src/pic.jpg] 82 bytes &#123;main&#125; [built] 复制的文件名是可以改的，输出位置也可以通过options选项可以配置：1234567891011121314module:&#123; rules:[ &#123; test:/\.(jpe?g|png|gif)$/, use:&#123; loader:&quot;file-loader&quot;, options:&#123; name:&quot;[name]-[hash].[ext]&quot;,//[]表示占位符（placeholder），name表示源文件的名字，ext是源文件的后缀，还可以连接hash：[name]-[hash].[ext] outputPath:&quot;images/&quot;, #配置输出位置 &#125; &#125; &#125; ] &#125;, 运行命令打包如下：123456789101112131415F:\front-end\webpack\webpack-demos&gt;npx webpacknpx: 1 安装成功，用时 14.264 秒&apos;prefix&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。Hash: faabe6751318c1104e28Version: webpack 4.31.0Time: 294msBuilt at: 2019-05-19 21:57:04 Asset Size Chunks Chunk Names bundle.js 4.89 KiB main [emitted] mainimages/pic-91d98190304e9e52a3b55d37b5f60397.jpg 8.89 KiB [emitted]Entrypoint main = bundle.js[./src/a.js] 73 bytes &#123;main&#125; [built][./src/index.js] 77 bytes &#123;main&#125; [built][./src/pic.jpg] 93 bytes &#123;main&#125; [built] 很多loader都有一个叫做placeholder（占位符）的概念，可以有不同的占位符，比如名称、后缀、hash等。 静态模块：url-loader url-loader可以做file-loader可以做的所有事情，多出来的功能是：默认把静态资源转成base64格式并打包到bundle.js(最终的打包文件)，可以使用limit选项来设置是否转译范围。大于limit范围的不转译。安装：1npm i url-loader -D 配置：123456789101112131415module:&#123; rules:[ &#123; test:/\.(jpe?g|png|gif)$/, use:&#123; loader:&quot;url-loader&quot;, options:&#123; name:&quot;[name]-[hash].[ext]&quot;,//[]表示占位符，name表示源文件的名字，ext是源文件的后缀，还可以连接hash：[name]-[hash].[ext] outputPath:&quot;images/&quot;, limit:2048,//当url-loader处理jpg模块，会判断体积是否在限制范围之内，在limit之内的，就转成base64格式并打包到bundle.js，否则就不转直接输出到dist &#125; &#125; &#125; ] &#125;, 运行命令：1234567891011121314F:\front-end\webpack\webpack-demos&gt;npx webpacknpx: 1 安装成功，用时 5.906 秒&apos;prefix&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。Hash: 74ba975fbbf2f7d18da1Version: webpack 4.31.0Time: 328msBuilt at: 2019-05-19 22:02:46 Asset Size Chunks Chunk Namesbundle.js 16.7 KiB main [emitted] mainEntrypoint main = bundle.js[./src/a.js] 73 bytes &#123;main&#125; [built][./src/index.js] 77 bytes &#123;main&#125; [built][./src/pic.jpg] 11.9 KiB &#123;main&#125; [built] 这时候我们的dist目录下没有了图片了，在bundle.js中却多出来一堆base64的字符串，url-loader默认把图片转成了base64字符串。当图片小的时候，用url-loader可以减少请求数，但是图片大的时候，这样会增大打包文件的体积，所以需要有个度，可以使用options中的limit字段来设置文件是否转base64的限制，在限制范围内，就转译base64并打包到最终打包文件bundle.js，否则，就直接执行file-loader的功能，直接移动到输出目录。 样式文件模块：解释style-loader、css-loader、sass-loader、postcss-loader 处理css模块处理css模块需要两个loader：style-loader和css-loader css-loader工作机制：处理css模块，识别合并css模块 style-loader工作机制：把合并的css模块放到html中head的style标签中。 安装1npm i style-loader css-loader -D 配置：1234567891011module:&#123; rules:[ &#123; test:/\.css$/, use: [ #执行顺序：从下到上，从右到左 &apos;style-loader&apos;, #把合并的css放到style标签 &apos;css-loader&apos;, #先识别css并合并为一个css ], &#125;, ]&#125;, 在src目录中增加index.css123body&#123; background:blue;&#125; 在index.js中引入index.css1import &apos;./index.css&apos;; 运行命令：123456789101112131415161718F:\front-end\webpack\webpack-demos&gt;npx webpacknpx: 1 安装成功，用时 5.363 秒&apos;prefix&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。Hash: 01f1fa305f332e6c34fcVersion: webpack 4.31.0Time: 962msBuilt at: 2019-05-19 22:23:28 Asset Size Chunks Chunk Names bundle.js 24.6 KiB main [emitted] mainimages/pic-91d98190304e9e52a3b55d37b5f60397.jpg 8.89 KiB [emitted]Entrypoint main = bundle.js[./node_modules/css-loader/dist/cjs.js!./src/index.css] 175 bytes &#123;main&#125; [built][./src/a.js] 73 bytes &#123;main&#125; [built][./src/index.css] 1.06 KiB &#123;main&#125; [built][./src/index.js] 102 bytes &#123;main&#125; [built][./src/pic.jpg] 93 bytes &#123;main&#125; [built] + 3 hidden modules 可以看到成功打包了index.css，在浏览器打开index.html，可以看到css生效了： 处理scss模块样式文件有很多种写法，这里以sass为例，sass的文件后缀是scss，处理sass文件需要style-loader、css-loader、sass-loader，安装：12#sass-loader把sass语法转换成css，依赖node-sass模块npm i scss-loader node-sass -D 配置：123456789101112module:&#123; rules:[ &#123; test:/\.scss$/, use:[ &apos;style-loader&apos;,//放在正确的打包位置 &apos;css-loader&apos;,//打包合并css &apos;sass-loader&apos;,//处理sass，转成css ] &#125; ]&#125;, 在src下新增index.scss:12345html&#123; body&#123; background:blue; &#125;&#125; 修改index.js，引入index.scss12345678import a from &quot;./a&quot;a()var pic = require(&apos;./pic.jpg&apos;);console.log(pic)// import &apos;./index.css&apos;;import &apos;./index.scss&apos;; 删除dist目录，执行命令：123456789101112131415161718F:\front-end\webpack\webpack-demos&gt;npx webpacknpx: 1 安装成功，用时 15.772 秒&apos;prefix&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。Hash: b704540cce4d7e089aeaVersion: webpack 4.31.0Time: 3343msBuilt at: 2019-05-20 06:29:40 Asset Size Chunks Chunk Names bundle.js 24.9 KiB main [emitted] mainimages/pic-91d98190304e9e52a3b55d37b5f60397.jpg 8.89 KiB [emitted]Entrypoint main = bundle.js[./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/lib/loader.js!./src/index.scss] 176 bytes &#123;main&#125; [built][./src/a.js] 73 bytes &#123;main&#125; [built][./src/index.js] 129 bytes &#123;main&#125; [built][./src/index.scss] 1.18 KiB &#123;main&#125; [built][./src/pic.jpg] 93 bytes &#123;main&#125; [built] + 3 hidden modules 可以看到成功打包了scss模块，在浏览器打开index.html，样式成功渲染： 自动给样式增加前缀：postcss-loader一般来说开发之中还会对样式模块的loader增加一个处理：自动给样式增加前缀（-webkit-，-o-等浏览器兼容前缀），这样就不用自己一个个的写了。postcss-loader可以自定识别需要增加前缀的样式，自动给他们增加前缀代码。安装：12#autoprefixer是增加前缀的依赖包npm i postcss-loader autoprefixer -D 配置：12345678910111213module:&#123; rules:[ &#123; test:/\.scss$/, use:[ &apos;style-loader&apos;,//放在正确的打包位置 &apos;css-loader&apos;,//打包合并css &apos;sass-loader&apos;,//处理sass，转成css &apos;postcss-loader&apos;//自定增加前缀 ] &#125; ]&#125;, 增加postcss-loader配置文件，在根目录下新建postcss.config.js12345module.exports = &#123; plugins:[ require(&apos;autoprefixer&apos;) ]&#125; 在index.html中修改：1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;demo&quot;&gt; &lt;/div&gt; &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在index.scss增加css3代码：1234567891011html&#123; body&#123; background: green; .demo&#123; width:200px; height:200px; background: red; transform:translate(100px,100px) &#125; &#125;&#125; 运行命令：123456789101112131415161718F:\front-end\webpack\webpack-demos&gt;npx webpacknpx: 1 安装成功，用时 4.451 秒&apos;prefix&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。Hash: 6d8a1bc0a093edc5c610Version: webpack 4.31.0Time: 1342msBuilt at: 2019-05-20 06:44:47 Asset Size Chunks Chunk Names bundle.js 25.3 KiB main [emitted] mainimages/pic-91d98190304e9e52a3b55d37b5f60397.jpg 8.89 KiB [emitted]Entrypoint main = bundle.js[./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/lib/loader.js!./node_modules/postcss-loader/src/index.js!./src/index.scss] ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/lib/loader.js!./node_modules/postcss-loader/src!./src/index.scss 350 bytes &#123;main&#125; [built][./src/a.js] 73 bytes &#123;main&#125; [built][./src/index.js] 129 bytes &#123;main&#125; [built][./src/index.scss] 1.31 KiB &#123;main&#125; [built][./src/pic.jpg] 93 bytes &#123;main&#125; [built] + 3 hidden modules 可以看到成功打包了，浏览器刷新：可以看到css中自动增加了浏览器兼容前缀代码。 什么是PluginsPlugins是开始打包时，在某个时刻，帮助我们处理一些什么事情的机制，它是事件驱动的，本身是一个类。一种插件就是一种函数，通过传入不同的参数，可以实现不同的功能。 自动生成html HtmlWebpackPlugin是在打包后的时刻，自动帮你生成一个引入了打包后的JS的html，并放到输出目录下的一个插件。 安装1npm i html-webpack-plugin -D 配置：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const path = require(&apos;path&apos;);const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = &#123; entry:&quot;./src/index.js&quot;, // entry:&#123; // main:&apos;./index.js&apos; // &#125;, output:&#123; filename:&apos;bundle.js&apos;, //绝对路径 path:path.resolve(__dirname,&apos;dist&apos;) &#125;, mode:&quot;development&quot;, //不认识的模块（不是js)的配置 module:&#123; rules:[ // &#123; // test:/\.(jpe?g|png|gif)$/, // use:&#123; // loader:&quot;file-loader&quot;, // options:&#123; // name:&quot;[name]-[hash].[ext]&quot;,//[]表示占位符，name表示源文件的名字，ext是源文件的后缀，还可以连接hash：[name]-[hash].[ext] // outputPath:&quot;images/&quot;, // &#125; // &#125; // &#125;, &#123; test:/\.(jpe?g|png|gif)$/, use:&#123; loader:&quot;url-loader&quot;, options:&#123; name:&quot;[name]-[hash].[ext]&quot;,//[]表示占位符，name表示源文件的名字，ext是源文件的后缀，还可以连接hash：[name]-[hash].[ext] outputPath:&quot;images/&quot;, limit:2048,//当url-loader处理jpg模块，会判断体积是否在限制范围之内，在limit之内的，就转成base64格式并打包到bundle.js，否则就不转直接输出到dist &#125; &#125; &#125;, &#123; test:/\.scss$/, use:[ &apos;style-loader&apos;,//放在正确的打包位置 &apos;css-loader&apos;,//打包合并css &apos;sass-loader&apos;,//处理sass，转成css &apos;postcss-loader&apos; ] &#125; ] &#125;, //配置插件，是个数组，里面的项是插件的实例 plugins:[ //自动生成html，并移到输出目录 new HtmlWebpackPlugin(&#123; title:&apos;html模板&apos;, filename:&apos;index.html&apos;, template:&quot;./index.html&quot; #生成html的模板路径 &#125;), ],&#125; 删除dist目录，删除html模板（此时根目录下的index.html）中自己加上去的script引入，运行命令：1234567891011121314151617181920212223242526F:\front-end\webpack\webpack-demos&gt;npx webpacknpx: 1 安装成功，用时 12.055 秒&apos;prefix&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。Hash: 72bd3988b3ab5a7aeb46Version: webpack 4.31.0Time: 4965msBuilt at: 2019-05-20 21:13:57 Asset Size Chunks Chunk Names bundle.js 25.3 KiB main [emitted] mainimages/pic-91d98190304e9e52a3b55d37b5f60397.jpg 8.89 KiB [emitted] index.html 406 bytes [emitted]Entrypoint main = bundle.js[./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/lib/loader.js!./node_modules/postcss-loader/src/index.js!./src/index.scss] ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/lib/loader.js!./node_modules/postcss-loader/src!./src/index.scss 350 bytes &#123;main&#125; [built][./src/a.js] 73 bytes &#123;main&#125; [built][./src/index.js] 129 bytes &#123;main&#125; [built][./src/index.scss] 1.31 KiB &#123;main&#125; [built][./src/pic.jpg] 93 bytes &#123;main&#125; [built] + 3 hidden modulesChild html-webpack-plugin for &quot;index.html&quot;: 1 asset Entrypoint undefined = index.html [./node_modules/html-webpack-plugin/lib/loader.js!./index.html] 569 bytes &#123;0&#125; [built] [./node_modules/webpack/buildin/global.js] (webpack)/buildin/global.js 472 bytes &#123;0&#125; [built] [./node_modules/webpack/buildin/module.js] (webpack)/buildin/module.js 497 bytes &#123;0&#125; [built] + 1 hidden module 成功打包，输出的dist目录下多了一个index.html，里面自动加上了打包后的js 自动删除dist目录我们每次在打包时，文件都是已覆盖已有的，不删除多余的。所以dist目录如果不手动删除，就会有很多多余文件，因此我们可以使用一个插件帮助我们执行删除dist目录的操作。 CleanWebpackPlugin插件是在打包之前，自动帮我们删除dist目录，以免污染打包环境。 安装：1npm i clean-webpack-plugin -D 配置：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const path = require(&apos;path&apos;);const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);module.exports = &#123; entry:&quot;./src/index.js&quot;, // entry:&#123; // main:&apos;./index.js&apos; // &#125;, output:&#123; filename:&apos;bundle.js&apos;, //绝对路径 path:path.resolve(__dirname,&apos;dist&apos;) &#125;, mode:&quot;development&quot;, //不认识的模块（不是js)的配置 module:&#123; rules:[ // &#123; // test:/\.(jpe?g|png|gif)$/, // use:&#123; // loader:&quot;file-loader&quot;, // options:&#123; // name:&quot;[name]-[hash].[ext]&quot;,//[]表示占位符，name表示源文件的名字，ext是源文件的后缀，还可以连接hash：[name]-[hash].[ext] // outputPath:&quot;images/&quot;, // &#125; // &#125; // &#125;, &#123; test:/\.(jpe?g|png|gif)$/, use:&#123; loader:&quot;url-loader&quot;, options:&#123; name:&quot;[name]-[hash].[ext]&quot;,//[]表示占位符，name表示源文件的名字，ext是源文件的后缀，还可以连接hash：[name]-[hash].[ext] outputPath:&quot;images/&quot;, limit:2048,//当url-loader处理jpg模块，会判断体积是否在限制范围之内，在limit之内的，就转成base64格式并打包到bundle.js，否则就不转直接输出到dist &#125; &#125; &#125;, &#123; test:/\.scss$/, use:[ &apos;style-loader&apos;,//放在正确的打包位置 &apos;css-loader&apos;,//打包合并css &apos;sass-loader&apos;,//处理sass，转成css &apos;postcss-loader&apos; ] &#125; ] &#125;, plugins:[ #执行顺序从上到下 new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; title:&apos;html模板&apos;, filename:&apos;index.html&apos;, template:&quot;./index.html&quot; &#125;), ],&#125; 自动导出css如果不想让css放在style标签中，我们可以使用插件来帮我们抽离css并打包输出到dist目录。 MiniCssExtractPlugin可以帮我们代替style-loader，抽离css，并输出到dist目录 安装：1npm i mini-css-extract-plugin -D 配置：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 const path = require(&apos;path&apos;);const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);module.exports = &#123; entry:&quot;./src/index.js&quot;, // entry:&#123; // main:&apos;./index.js&apos; // &#125;, output:&#123; filename:&apos;bundle.js&apos;, //绝对路径 path:path.resolve(__dirname,&apos;dist&apos;) &#125;, mode:&quot;development&quot;, //不认识的模块（不是js)的配置 module:&#123; rules:[ // &#123; // test:/\.(jpe?g|png|gif)$/, // use:&#123; // loader:&quot;file-loader&quot;, // options:&#123; // name:&quot;[name]-[hash].[ext]&quot;,//[]表示占位符，name表示源文件的名字，ext是源文件的后缀，还可以连接hash：[name]-[hash].[ext] // outputPath:&quot;images/&quot;, // &#125; // &#125; // &#125;, &#123; test:/\.(jpe?g|png|gif)$/, use:&#123; loader:&quot;url-loader&quot;, options:&#123; name:&quot;[name]-[hash].[ext]&quot;,//[]表示占位符，name表示源文件的名字，ext是源文件的后缀，还可以连接hash：[name]-[hash].[ext] outputPath:&quot;images/&quot;, limit:2048,//当url-loader处理jpg模块，会判断体积是否在限制范围之内，在limit之内的，就转成base64格式并打包到bundle.js，否则就不转直接输出到dist &#125; &#125; &#125;, &#123; test:/\.scss$/, use:[ &#123; loader: MiniCssExtractPlugin.loader, options: &#123; publicPath: &apos;../&apos;, hmr: process.env.NODE_ENV === &apos;development&apos;, &#125;, &#125;, &apos;css-loader&apos;,//打包合并css &apos;sass-loader&apos;,//处理sass，转成css &apos;postcss-loader&apos; ] &#125; ] &#125;, plugins:[ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; title:&apos;html模板&apos;, filename:&apos;index.html&apos;, template:&quot;./index.html&quot; &#125;), new MiniCssExtractPlugin(&#123; filename: &apos;[name].css&apos;, #输出文件名 chunkFilename: &apos;[id].css&apos;, #模块名 &#125;), ],&#125; 执行命令：123456789101112131415161718192021222324252627282930F:\front-end\webpack\webpack-demos&gt;npx webpacknpx: 1 安装成功，用时 3.619 秒&apos;prefix&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。Hash: dd2b22f9beb8876949e7Version: webpack 4.31.0Time: 2052msBuilt at: 2019-05-20 21:45:17 Asset Size Chunks Chunk Names bundle.js 5.5 KiB main [emitted] mainimages/pic-91d98190304e9e52a3b55d37b5f60397.jpg 8.89 KiB [emitted] index.html 399 bytes [emitted] main.css 204 bytes main [emitted] mainEntrypoint main = main.css bundle.js[./src/a.js] 73 bytes &#123;main&#125; [built][./src/index.js] 127 bytes &#123;main&#125; [built][./src/index.scss] 39 bytes &#123;main&#125; [built][./src/pic.jpg] 93 bytes &#123;main&#125; [built] + 1 hidden moduleChild html-webpack-plugin for &quot;index.html&quot;: 1 asset Entrypoint undefined = index.html [./node_modules/html-webpack-plugin/lib/loader.js!./index.html] 521 bytes &#123;0&#125; [built] [./node_modules/webpack/buildin/global.js] (webpack)/buildin/global.js 472 bytes &#123;0&#125; [built] [./node_modules/webpack/buildin/module.js] (webpack)/buildin/module.js 497 bytes &#123;0&#125; [built] + 1 hidden moduleChild mini-css-extract-plugin node_modules/css-loader/dist/cjs.js!node_modules/sass-loader/lib/loader.js!node_modules/postcss-loader/src/index.js!src/index.scss: Entrypoint mini-css-extract-plugin = * [./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/lib/loader.js!./node_modules/postcss-loader/src/index.js!./src/index.scss] ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/lib/loader.js!./node_modules/postcss-loader/src!./src/index.scss 350 bytes &#123;mini-css-extract-plugin&#125; [built] + 1 hidden module 输出日志中可以看到mini-css-extract-plugin的工作流程，dist目录下多了一个main.css文件，输出的index.html中自动增加了main.css。 开发模式排查问题：SourceMap默认情况下，如果代码有了错误，浏览器会直接定位到bundle.js，很难找到是哪里出了错，但是我们可以通过开启SourceMap来帮助我们定位错误。mode为development时，是默认开启SourceMap的，当关闭开发模式时，我们可以使用devtool来设置SourceMap devtool是设置打包时的文件映射，文件映射越完整，打包速度越慢，devtool可以设置各种速度和程度的打包及文件映射。 设置：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const path = require(&apos;path&apos;);const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);module.exports = &#123; entry:&quot;./src/index.js&quot;, // entry:&#123; // main:&apos;./index.js&apos; // &#125;, output:&#123; filename:&apos;bundle.js&apos;, //绝对路径 path:path.resolve(__dirname,&apos;dist&apos;) &#125;, mode:&quot;development&quot;, //不认识的模块（不是js)的配置 module:&#123; rules:[ // &#123; // test:/\.(jpe?g|png|gif)$/, // use:&#123; // loader:&quot;file-loader&quot;, // options:&#123; // name:&quot;[name]-[hash].[ext]&quot;,//[]表示占位符，name表示源文件的名字，ext是源文件的后缀，还可以连接hash：[name]-[hash].[ext] // outputPath:&quot;images/&quot;, // &#125; // &#125; // &#125;, &#123; test:/\.(jpe?g|png|gif)$/, use:&#123; loader:&quot;url-loader&quot;, options:&#123; name:&quot;[name]-[hash].[ext]&quot;,//[]表示占位符，name表示源文件的名字，ext是源文件的后缀，还可以连接hash：[name]-[hash].[ext] outputPath:&quot;images/&quot;, limit:2048,//当url-loader处理jpg模块，会判断体积是否在限制范围之内，在limit之内的，就转成base64格式并打包到bundle.js，否则就不转直接输出到dist &#125; &#125; &#125;, &#123; test:/\.scss$/, use:[ &#123; loader: MiniCssExtractPlugin.loader, options: &#123; publicPath: &apos;../&apos;, hmr: process.env.NODE_ENV === &apos;development&apos;, &#125;, &#125;, &apos;css-loader&apos;,//打包合并css &apos;sass-loader&apos;,//处理sass，转成css &apos;postcss-loader&apos; ] &#125; ] &#125;, plugins:[ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; title:&apos;html模板&apos;, filename:&apos;index.html&apos;, template:&quot;./index.html&quot; &#125;), new MiniCssExtractPlugin(&#123; filename: &apos;[name].css&apos;, //输出文件名 chunkFilename: &apos;[id].css&apos;, //模块名 &#125;), ], devtool:&apos;source-map&apos; //设置文件映射&#125; 执行命令：1234567891011121314151617181920212223242526272829303132F:\front-end\webpack\webpack-demos&gt;npx webpacknpx: 1 安装成功，用时 4.319 秒&apos;prefix&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。Hash: d599b2c86a9ac5ae3802Version: webpack 4.31.0Time: 1930msBuilt at: 2019-05-20 21:52:50 Asset Size Chunks Chunk Names bundle.js 5.29 KiB main [emitted] main bundle.js.map 4.19 KiB main [emitted] mainimages/pic-91d98190304e9e52a3b55d37b5f60397.jpg 8.89 KiB [emitted] index.html 399 bytes [emitted] main.css 240 bytes main [emitted] main main.css.map 401 bytes main [emitted] mainEntrypoint main = main.css bundle.js main.css.map bundle.js.map[./src/a.js] 73 bytes &#123;main&#125; [built][./src/index.js] 127 bytes &#123;main&#125; [built][./src/index.scss] 39 bytes &#123;main&#125; [built][./src/pic.jpg] 93 bytes &#123;main&#125; [built] + 1 hidden moduleChild html-webpack-plugin for &quot;index.html&quot;: 1 asset Entrypoint undefined = index.html [./node_modules/html-webpack-plugin/lib/loader.js!./index.html] 521 bytes &#123;0&#125; [built] [./node_modules/webpack/buildin/global.js] (webpack)/buildin/global.js 472 bytes &#123;0&#125; [built] [./node_modules/webpack/buildin/module.js] (webpack)/buildin/module.js 497 bytes &#123;0&#125; [built] + 1 hidden moduleChild mini-css-extract-plugin node_modules/css-loader/dist/cjs.js!node_modules/sass-loader/lib/loader.js!node_modules/postcss-loader/src/index.js!src/index.scss: Entrypoint mini-css-extract-plugin = * [./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/lib/loader.js!./node_modules/postcss-loader/src/index.js!./src/index.scss] ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/lib/loader.js!./node_modules/postcss-loader/src!./src/index.scss 350 bytes &#123;mini-css-extract-plugin&#125; [built] + 1 hidden module 可以看到dist目录里多了后缀为map的文件，这些文件就是打包文件与源码的映射文件，有助于我们定位错误，调试代码。开发模式下我们可以使用模式“cheap-module-eval-source-map”，这个模式定位错误到行，并且可以定位第三方模块的错误并输出。 本地服务器：devServer前端开发离不开这个利器：本地服务器，可以配置devServer并配合插件实现修改代码浏览器同步刷新，实时查看修改效果。 WebpackDevServer 安装：1npm i webpack-dev-server -D 修改package.json123&quot;scripts&quot;: &#123; &quot;server&quot;: &quot;webpack-dev-server&quot;,&#125;, 配置devServer：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103const path = require(&apos;path&apos;);const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);module.exports = &#123; // entry:&quot;./index.js&quot;, entry:&#123; main:&apos;./index.js&apos; &#125;, output:&#123; filename:&apos;bundle.js&apos;, //绝对路径 path:path.resolve(__dirname,&apos;dist&apos;) &#125;, devServer:&#123; contentBase:&apos;./dist&apos;, //服务器启动的目录 open:true, //自动打开浏览器 proxy:&#123; //设置代理，可用于本地mock数据，本地自己启动另外一个服务 &quot;/api&quot;:&#123; target:&quot;http://localhost:9092&quot; &#125; &#125;, port:8083, //指定端口号 hot:true, //开启HMR(Hot Module Replacement)热模块替换,由于是webpack自带的，所以要引入webpack ，监控并更新js模块的工作vue等框架自己做了，否则需要自己手动监控 hotOnly:true &#125;, //不认识的模块（不是js)的配置 module:&#123; rules:[ &#123; test:/\.js$/,exclude:/node_modules/, loader:&quot;babel-loader&quot;, options:&#123; // &quot;presets&quot;:[[&quot;@babel/preset-env&quot;,&#123; // useBuiltIns:&quot;usage&quot; // &#125;]] // plugins:[[&quot;@babel-plugin-transform-runtime&quot;,&#123; // &quot;absolute&quot; // &#125;] &#125; &#125;, &#123; test:/\.(jpe?g|png|gif)$/, use:&#123; loader:&quot;url-loader&quot;, options:&#123; name:&quot;[name]-[hash].[ext]&quot;,//[]表示占位符，name表示源文件的名字，ext是源文件的后缀，还可以连接hash：[name]-[hash].[ext] outputPath:&quot;images/&quot;, limit:2048,//当webpack处理jpg模块，会判断体积是否在限制范围之内，y限制在体积小于2048的 &#125; &#125; &#125;, &#123; test:/\.css$/, use: [ // &#123; // loader: MiniCssExtractPlugin.loader, // options: &#123; // // you can specify a publicPath here // // by default it uses publicPath in webpackOptions.output // publicPath: &apos;../&apos;, // hmr: process.env.NODE_ENV === &apos;development&apos;, // &#125;, // &#125;, &apos;style-loader&apos;, &apos;css-loader&apos;, &apos;postcss-loader&apos; ], // [ // &apos;style-loader&apos;, // &apos;css-loader&apos;, // &apos;postcss-loader&apos; // ] &#125;, &#123; test:/\.scss$/, use:[ &apos;style-loader&apos;,//放在正确的打包位置 &apos;css-loader&apos;,//打包合并css &apos;sass-loader&apos;,//处理sass，转成css &apos;postcss-loader&apos; ] &#125; ] &#125;, plugins:[ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; title:&apos;html模板&apos;, template:&quot;./index.html&quot; &#125;), // new MiniCssExtractPlugin(&#123; // // Options similar to the same options in webpackOptions.output // // both options are optional // filename: &apos;[name].css&apos;, // chunkFilename: &apos;[id].css&apos;, // &#125;), new webpack.HotModuleReplacementPlugin() ], devtool:&apos;inline-source-map&apos;,//打包后的文件映射 mode:&quot;development&quot;//去掉警告，开发模式&#125; 执行命令：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748F:\front-end\webpack\webpack-demos&gt;npm run server&gt; demo@1.0.0 server F:\front-end\webpack\webpack-demos&gt; webpack-dev-serveri ｢wds｣: Project is running at http://localhost:8083/i ｢wds｣: webpack output is served from /i ｢wds｣: Content not from webpack is served from ./disti ｢wdm｣: Hash: 06f7a27fe38a8a9b134aVersion: webpack 4.31.0Time: 4661msBuilt at: 2019-05-20 22:24:21 Asset Size Chunks Chunk Names bundle.js 367 KiB main [emitted] main bundle.js.map 419 KiB main [emitted] mainimages/pic-91d98190304e9e52a3b55d37b5f60397.jpg 8.89 KiB [emitted] index.html 399 bytes [emitted] main.css 240 bytes main [emitted] main main.css.map 401 bytes main [emitted] mainEntrypoint main = main.css bundle.js main.css.map bundle.js.map[0] multi (webpack)-dev-server/client?http://localhost:8083 (webpack)/hot/only-dev-server.js ./src/index.js 52 bytes &#123;main&#125; [built][./node_modules/loglevel/lib/loglevel.js] 7.68 KiB &#123;main&#125; [built][./node_modules/querystring-es3/index.js] 127 bytes &#123;main&#125; [built][./node_modules/url/url.js] 22.8 KiB &#123;main&#125; [built][./node_modules/webpack-dev-server/client/index.js?http://localhost:8083] (webpack)-dev-server/client?http://localhost:8083 9.26 KiB &#123;main&#125; [built][./node_modules/webpack-dev-server/client/overlay.js] (webpack)-dev-server/client/overlay.js 3.59 KiB &#123;main&#125; [built][./node_modules/webpack-dev-server/client/socket.js] (webpack)-dev-server/client/socket.js 1.05 KiB &#123;main&#125; [built][./node_modules/webpack-dev-server/node_modules/strip-ansi/index.js] (webpack)-dev-server/node_modules/strip-ansi/index.js 161 bytes &#123;main&#125; [built][./node_modules/webpack/hot sync ^\.\/log$] (webpack)/hot sync nonrecursive ^\.\/log$ 170 bytes &#123;main&#125; [built][./node_modules/webpack/hot/emitter.js] (webpack)/hot/emitter.js 75 bytes &#123;main&#125; [built][./node_modules/webpack/hot/log-apply-result.js] (webpack)/hot/log-apply-result.js 1.27 KiB &#123;main&#125; [built][./node_modules/webpack/hot/log.js] (webpack)/hot/log.js 1.11 KiB &#123;main&#125; [built][./node_modules/webpack/hot/only-dev-server.js] (webpack)/hot/only-dev-server.js 2.55 KiB &#123;main&#125; [built][./src/a.js] 73 bytes &#123;main&#125; [built][./src/index.js] 127 bytes &#123;main&#125; [built] + 17 hidden modulesChild html-webpack-plugin for &quot;index.html&quot;: 1 asset Entrypoint undefined = index.html [./node_modules/html-webpack-plugin/lib/loader.js!./index.html] 521 bytes &#123;0&#125; [built] [./node_modules/lodash/lodash.js] 527 KiB &#123;0&#125; [built] [./node_modules/webpack/buildin/global.js] (webpack)/buildin/global.js 472 bytes &#123;0&#125; [built] [./node_modules/webpack/buildin/module.js] (webpack)/buildin/module.js 497 bytes &#123;0&#125; [built]Child mini-css-extract-plugin node_modules/css-loader/dist/cjs.js!node_modules/sass-loader/lib/loader.js!node_modules/postcss-loader/src/index.js!src/index.scss: Entrypoint mini-css-extract-plugin = * [./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/lib/loader.js!./node_modules/postcss-loader/src/index.js!./src/index.scss] ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/lib/loader.js!./node_modules/postcss-loader/src!./src/index.scss 350 bytes &#123;mini-css-extract-plugin&#125; [built] [./node_modules/css-loader/dist/runtime/api.js] 2.35 KiB &#123;mini-css-extract-plugin&#125; [built]i ｢wdm｣: Compiled successfully. 自动打开浏览器：]]></content>
      <categories>
        <category>WebPack</category>
      </categories>
      <tags>
        <tag>WebPack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令总结]]></title>
    <url>%2F2019%2F05%2F18%2Fgit%2F</url>
    <content type="text"><![CDATA[#Git介绍 定义：Linus Torvalds 开发的一个开放源码的版本控制软件，是一个开源的分布式版本控制系统、内容管理系统(CMS)，工作管理系统等（记录你的文本文件每次修改，协作团队编辑等）对手：SVN、CVS等 登录当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中在Git Bash中输入：123456#当前项目注册，只有当前项目使用这个账号git config user.name &quot;Your Name&quot;git config user.email &quot;email@example.com&quot;#全局注册，这台机器上所有的Git仓库都会使用这个账号git config --global user.name &quot;Your Name&quot; git config --global user.email &quot;email@example.com&quot; 查看你的配置：12git config --list #列出所有 Git 当时能找到的配置git config user.name #检查 Git 的某一项配置 查看帮助手册1git help &lt;verb&gt; 本地仓库创建Git库版本库又名仓库，英文名repository，版本库中所有文件都可以被Git管理、追踪、记录。创建一个空的版本库：1git init 该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，不可删除，默认是隐藏文件夹，可以设置文件夹查看文件的设置来查看.git文件，也可以运行命令ls -ah来查看当前目录的隐藏文件 Git提交本地库流程12345git add . #添加全部文件到仓库#git add &lt;filename&gt;git add &lt;文件.后缀&gt; #添加特定文件到仓库git add &lt;文件.后缀&gt; &lt;文件.后缀&gt; #添加多个特定文件到仓库git commit -m &quot;comment message&quot; #提交并添加本次提交的说明，每一次提交都是一个仓库快照，可以用于恢复或回退 git add命令可以执行多次。 状态管理查看仓库状态123456#查看仓库当前的状态，可以知道修改的文件，当前提交的状态等git status #查看仓库当前的状态git status –short #查看仓库当前状态的简化git status -s #git status –short简写git diff &lt;文件名.后缀&gt; #查看特定文件修改对比，diff就是difference,只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动git diff HEAD -- &lt;文件名.后缀&gt; #查看工作区与已提交的最新版本的特定文件的区别 查看历史记录1234567git log #显示从最近到最远的提交日志git log --pretty=oneline #简化日志，把每次提交展现为一行git log -p -2 # -p，用来显示每次提交的内容差异。 -2 仅显示最近两次提交git log --stat #提交的简略的统计信息git log --pretty=format:&quot;%h - %an, %ar : %s&quot; # format，可以定制要显示的记录格式。git log --since=2.weeks #列出所有最近两周内的提交git reflog #查看每次commit信息，git的后悔药 版本回退每次commit都会有一个commitID记录这次提交的版本，HEAD是最新的版本，上一个版本为HEAD^,上100个版本为HEAD~100123git reset --hard commit_id #回退到特定提交，需要知道commit_id，commit_id可以不用写完整，Git会自动查找，写前面几个足够识别的就可以。git reset --hard HEAD~1 #回退到上一次提交git reset --hard 1094a #当回退反悔之后，如果当前窗口未关闭，还可以找到之前的commitID,就可以再退到特定版本，往前往后都可以 撤销修改123456git reset HEAD &lt;file&gt; #把暂存区的修改回退到工作区git checkout -- &lt;文件名.后缀&gt; #特定文件在工作区的修改全部撤销，即让这个文件回到最近一次git commit或git add时的状态，此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件#丢弃本地修改，用远程库覆盖git fetch origin #先拉取git reset --hard origin/master #将你本地主分支重置到远程库主分支 删除文件1234 #从版本库（本地仓库）中删除某个特定文件git rm file #下一次提交时，该文件就不再纳入版本管理了，如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母）git rm -f file #删除已暂存即add的文件git commit -m &quot;remove file&quot; 12#用版本库里的版本替换工作区的版本，相当于一键还原git checkout -- test.txt 修改名称1git mv file_from file_to #对文件改名 远程仓库 建立关联123ssh-keygen -t rsa -C &quot;youremail@example.com&quot; #创建SSH Key,然后添加到github远程仓库#git remote add origin &lt;server&gt;git remote add origin git@github.com:youname/name.git 本地推送123#git push &lt;仓库名称&gt; &lt;分支名称&gt;git push -u origin master #当前分支master推送到远程，第一次需要-u来关联本地和远程库，后面就不用了 git push origin master 克隆仓库12#git clone username@host:/path/to/repositorygit clone git@github.com:yourname/name.git #从本地克隆已有的远处仓库 分支关联 在你创建仓库的时候，master 是“默认的”。在其他分支上进行开发，完成后再将它们合并到主分支上。 创建和合并分支123456git checkout -b dev #git checkout命令加上-b参数表示创建并切换git branch dev #创建分支git checkout dev #切换分支git branch #查看当前分支git merge dev #合并指定分支到当前分支git branch -d dev #删除分支 解决冲突12345git merge dev #合并时可能会有冲突，有冲突之后要手动解决冲突git add readme.txt #解决掉冲突之后添加到暂存区git commit -m &quot;conflict fixed&quot; #然后提交git log --graph --pretty=oneline --abbrev-commit #查看分支的合并情况git log --graph #可以看到分支合并图 分支策略 master分支应该是非常稳定的，仅用来发布新版本，平时不能在上面工作 工作都在各自的dev分支上，dev分支是不稳定的，开发完毕时，再把dev分支合并到master上，在master分支发布1.0版本 工作流：1234567 git checkout -b dev #创建并切换到新分支 git add readme.txt #在工作分支修改之后添加到暂存区 git commit -m &quot;add merge&quot; #然后提交到仓库git checkout master #要合并时切换到主分支git merge --no-ff -m &quot;merge with no-ff&quot; dev #合并分支，使用--no-ff表示禁用Fast forward（不能查看合并情况），-m参数，把commit描述写进去git log --graph --pretty=oneline --abbrev-commit #查看分支历史git branch -d dev #合并完毕后，删除分支 通常，合并分支时，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息，从而可以查看合并分支图 修复BUG一般来说，修复BUG我们也会新建一个BUG分支，修复完毕之后合并主分支，如果你的工作分支上还有工作没做完但是不能commit的，可以暂存。流程：1234567891011121314git status #来BUG了，查看当前仓库状态，有没有没提交的git stash #把当前工作现场“储藏”起来git checkout master #切换到需要修复BUG的分支git checkout -b issue-101 #创建并切换BUG分支git add readme.txt #修复BUG后提交暂存区git commit -m &quot;fix bug 101&quot; #提交仓库git checkout master #修复完成，切换分支git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101 #合并BUG分支和要修复的分支git checkout dev #切换到工作分支git stash list #查看工作存储git stash pop #恢复工作现场的同时把stash内容也删了git stash apply #恢复工作现场（git stash pop命令的分解1）git stash drop #删除stash（git stash pop命令的分解2）git stash apply stash@&#123;0&#125; #恢复指定的工作现场 新功能分支新功能开发流程：1234567git checkout -b feature-vulcan #创建并切换新功能分支git add vulcan.py #开发完毕后添加暂存区git status #查看当前仓库状态，确认文件git commit -m &quot;add feature vulcan&quot; #提交仓库git checkout dev #切换工作分支，准备合并git branch -d feature-vulcan #删除新功能分支git branch -D feature-vulcan #没有合并的分支要删除需要用-D 团队协作团队协作流程1234567891011121314151617git remote #查看远程库信息，当前是哪个分支git remote -v #查看详细信息，显示了可以抓取和推送的origin的地址git clone git@github.com:youname/name.git #克隆分支git checkout -b dev origin/dev #创建远程工作分支到本地（在本地创建和远程分支对应的分支）git add env.txt #修改之后添加到暂存区git commit -m &quot;add env&quot; #提交到本地仓库#git push origin &lt;branch&gt;git push origin master #推送主分支 git push origin dev #推送其他分支git pull #推送过程有冲突，先把最新的提交从origin/dev抓下来，在本地合并，解决冲突，再推送git diff &lt;source_branch&gt; &lt;target_branch&gt; #查看分支不同git branch --set-upstream-to=origin/dev dev #没有指定本地dev分支与远程origin/dev分支的链接时，设置dev和origin/dev的链接（建立本地分支和远程分支的关联）git pull #设置之后继续拉取git add env.txt #有冲突之后解决冲突，添加暂存区git commit -m &quot;fix env conflict&quot; #提交仓库git push origin dev #推送git rebase #如果本地未push的分支提交分叉太多，可以把本地未push的分叉提交历史整理成直线之后再提交 标签管理 发布一个版本时，我们通常先在版本库中打一个标签（tag），标签也是版本库的一个快照，标签（tag）就是一个让人容易记住的有意义的名字（如v1.2等），它跟某个commit绑在一起，更方便管理查找。 创建标签创建标签流程：12345678git branch #查看当前的分支git checkout marster #切换到要打标签的分支git tag v1.0 #打标签git tag #查看打的标签git log --pretty=oneline --abbrev-commit #当忘记打标签时，查找历史commitgit tag v0.9 f52c633 #对历史commit打标签git show v0.9 #查看标签信息git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb #打带有说明的标签，用-a指定标签名，-m指定说明文字 操作标签1234567git tag -d v0.1 #删除标签git push origin v1.0 #打的标签是在本地，需要推送到远程仓库git push origin &lt;tagname&gt;git push origin --tags #次性推送全部尚未推送到远程的本地标签#标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除git tag -d v0.9 git push origin :refs/tags/v0.9 #推送删除标签git push origin :refs/tags/&lt;tagname&gt; 使用github 一般使用GitHub作为免费的git远程仓库，可以管理自己的仓库，也可以参与别的开源项目。参与github上开源项目流程： 在开源项目主页点fork，在自己的账号下克隆一个开源项目仓库 从自己的账号下克隆下这个开源项目仓库 1git clone git@github.com:youname/name.git 修改自己账号下的开源仓库 推送pull request给官方开源项目仓库来贡献代码 自定义git 一些有用的命令：12git config --global color.ui true #彩色的 git 输出git config format.pretty oneline #显示历史记录时，只显示一行注释信息 忽略特殊文件在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件，提交的时候就不会把这些文件提交上去。官方的.gitignore文件模板：https://github.com/github/gitignore.gitignore需要也提交到Git，检验.gitignore的标准是git status命令是不是说working directory clean。.gitignore例子：1234567891011121314151617# no .a files*.a# but do track lib.a, even though you&apos;re ignoring .a files above!lib.a# only ignore the TODO file in the current directory, not subdir/TODO/TODO# ignore all files in the build/ directorybuild/# ignore doc/notes.txt, but not doc/server/arch.txtdoc/*.txt# ignore all .pdf files in the doc/ directorydoc/**/*.pdf 12git add -f App.class #-f表示强制添加文件，忽略ignore规则git check-ignore -v App.class #检查gitignore规则，是否忽略了文件 配置命令别名12git config --global alias.st status #git status 别名：git stgit config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot; #git log 设置颜色别名：git lg –global参数是全局参数，配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用查看最近一次提交：1git log -1 删除别名：每个仓库的Git配置文件都放在.git/config文件中，可以在配置文件中删除别名，别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。配置别名也可以直接修改这个文件。 参考链接：官网：https://git-scm.com/中文网：http://www.git-scm.com.cn/1511.htmlGit简易指南：http://www.bootcss.com/p/git-guide/Git命令手册：https://git-scm.com/docsGit教程：https://www.liaoxuefeng.com/wiki/896043488029600]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npx详细使用]]></title>
    <url>%2F2019%2F05%2F18%2Fnpx%2F</url>
    <content type="text"><![CDATA[前几天接触到了npx，发现这个命令非常好用，这里总结下npx的使用。 npx是什么？ npx是npm5.2之后发布的一个命令。官网说它是“execute npm package binaries”，就是执行npm依赖包的二进制文件，简而言之，就是我们可以使用npx来执行各种命令。npx官网：https://www.npmjs.com/package/npx 为什么要使用npx？ 解决的问题在命令行执行本地已安装的依赖包命令 使用npx可以在命令行直接执行本地已安装的依赖包命令，不用在scripts脚本写入命令，也不用麻烦的去找本地脚本。 首先来看这个场景：我们本地安装了一个依赖包：1npm i -D mocha 想要在本地（当前目录）执行它时，什么都不做时是不能运行这个命令的： 我们一般会使用几种方式来运行我们想要运行的命令： 使用package.json的scripts脚本1234//package.json&quot;scripts&quot;: &#123; &quot;findmocha&quot;: &quot;mocha --version&quot;,&#125; 然后在命令行运行：1npm run findmocha 在命令行中直接找到模块的二进制文件运行 全局安装模块 而使用npx，我们可以直接在命令行执行我们要运行的命令：12npm i -D mochanpx mocha --version 不用全局安装，直接在命令行执行一次性命令 有很多命令，我们只需要执行一次的，但是却要全局安装一次，实在不科学，使用npx，可以在不全局安装依赖包的情况下，运行命令，而且运行后不会污染全局环境 比如1npx create-react-app my-react-app npx 将create-react-app下载到一个临时目录，使用以后再删除。每次运行这个命令，都会重新下载依赖包，运行后删除。 切换node版本来运行命令 当你想要运行的命令不兼容当前的nodejs版本，可以通过npx来切换版本，指定某个版本的 Node 来运行命令。 npx的-p选项指定要安装的包，并将其添加到正在运行的$PATH中如：123npx node@6 -vnpx node@7 -vnpx node@8 -v 以上的命令，会自动下载需要的node，执行完命令后删除。 npx的原理npx的原理，就是在运行它时，执行下列流程： 去node_modules/.bin路径检查npx后的命令是否存在，找到之后执行； 找不到，就去环境变量$PATH里面，检查npx后的命令是否存在，找到之后执行; 还是找不到，自动下载一个临时的依赖包最新版本在一个临时目录，然后再运行命令，运行完之后删除，不污染全局环境。 安装和参数说明 安装1npm install -g npx 常用参数-p 参数-p参数用于指定 npx 所要安装的模块1npx -p node@6 node -v –no-install 参数强制使用本地模块，不下载远程模块，如果本地不存在该模块，就会报错。 –ignore-existing 参数忽略本地的同名模块，强制安装使用远程模块 使用场景总结使用npx执行 本地命令12npm i -D mochanpx mocha --version 使用npx一次性执行命令1npx create-react-app my-react-app 使用npx切换node版本1npx node@6 -v 使用npx执行 GitHub 源码1npx github:piuccio/cowsay 远程代码必须是一个模块，即必须包含package.json和入口脚本 使用npx开启一个静态服务器12npx http-server #默认返回根目录下index.htmlnpx http-server -p 3000 #指定端口 参考链接：https://www.npmjs.com/package/npxhttp://www.ruanyifeng.com/blog/2019/02/npx.htmlhttps://www.jianshu.com/p/a4d2d14f4c0e]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>npx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm基础知识和命令总结]]></title>
    <url>%2F2019%2F05%2F15%2Fnpm%2F</url>
    <content type="text"><![CDATA[npm是工作过程中很常用的包管理工具，这里记录汇总npm基础知识和命令。 npm是什么？ npm全称Node Package Manager，是node.js的模块依赖管理工具，它有一个日益强大的对手叫yarn，yarn是Facebook发布的一款依赖管理工具。 npm的使用场景：上传分享自己写的程序代码（包），下载别人写的程序代码（包）。 npm的组成： npm官网（https://www.npmjs.com/），用来管理设置上面的代码程序包 一个大数据库，大家分享的程序就放在那里 命令行工具（CLI），我们通过CLI来与npm交流npm怎么安装与升级 与NodeJs一起集成安装，安装NodeJS时安装npm。 查看npm版本12npm -v#6.5.0 查看帮助1npm help &lt;command&gt; 升级npm12npm install npm -gnpm install npm@latest -g #升级到最新版本 包是什么？ npm的核心是包，npm将它管理的程序都叫包，每个包里有个package.json文件，位于包的根目录下，用于定义包的属性（配置信息），比如包的名称、版本、许可证等等。在进行npm install命令时，就是根据这个配置文件，来自动下载这个包所需的模块，配置项目所需的运行和开发环境。 package.jsonpackage.json是一个JSON对象，每一个键值对就是当面包的一个配置。一个package.json常用字段:123456789101112131415161718192021222324252627282930313233343536373839404142&#123; &quot;name&quot;: &quot;Hello World&quot;, //包名 &quot;version&quot;: &quot;0.0.1&quot;,//包的版本号，主版本.次版本.补丁版本 &quot;author&quot;: &quot;张三&quot;,//包的作者，格式设置：Your Name &lt;email@example.com&gt; (http://example.com) &quot;description&quot;: &quot;第一个node.js程序&quot;,//包的描述 &quot;keywords&quot;:[&quot;node.js&quot;,&quot;javascript&quot;],//包的关键词 &quot;main&quot;:&quot;index.js&quot;,//main 字段指定了程序的主入口文件，require(&apos;moduleName&apos;) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。 &quot;repository&quot;: &#123;// 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。 &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://path/to/url&quot; &#125;, &quot;license&quot;:&quot;MIT&quot;,//包的版权协议 &quot;engines&quot;: &#123;&quot;node&quot;: &quot;0.10.x&quot;&#125;,//该模块运行的平台，比如 Node 的某个版本或者浏览器 &quot;bugs&quot;:&#123;&quot;url&quot;:&quot;http://path/to/bug&quot;,&quot;email&quot;:&quot;bug@example.com&quot;&#125;, &quot;contributors&quot;:[&#123;&quot;name&quot;:&quot;李四&quot;,&quot;email&quot;:&quot;lisi@example.com&quot;&#125;],//包的其他贡献者姓名 &quot;scripts&quot;: &#123;//运行脚本命令的npm命令行缩写，执行命令：npm run &lt;命令名&gt; &quot;start&quot;: &quot;node index.js&quot; &#125;, &quot;config&quot;:&#123;//添加命令行的环境变量 &quot;port&quot;:&quot;8080&quot;//可以在js中通过process.env.npm_package_config_port获取，可以通过npm config set &lt;包名&gt;:port 80修改 &#125;, &quot;browser&quot;: &#123;//供浏览器使用的版本 &quot;tipso&quot;: &quot;./node_modules/tipso/src/tipso.js&quot; &#125;, &quot;dependencies&quot;: &#123;//项目运行依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 * node_module 目录下 &quot;express&quot;: &quot;latest&quot;, &quot;mongoose&quot;: &quot;~3.8.3&quot;, &quot;handlebars-runtime&quot;: &quot;~1.0.12&quot;, &quot;express3-handlebars&quot;: &quot;~0.5.0&quot;, &quot;MD5&quot;: &quot;~1.2.0&quot; &#125;, &quot;devDependencies&quot;: &#123;//项目开发依赖包列表 &quot;bower&quot;: &quot;~1.2.8&quot;, &quot;grunt&quot;: &quot;~0.4.1&quot;, &quot;grunt-contrib-concat&quot;: &quot;~0.3.0&quot;, &quot;grunt-contrib-jshint&quot;: &quot;~0.7.2&quot;, &quot;grunt-contrib-uglify&quot;: &quot;~0.2.7&quot;, &quot;grunt-contrib-clean&quot;: &quot;~0.5.0&quot;, &quot;browserify&quot;: &quot;2.36.1&quot;, &quot;grunt-browserify&quot;: &quot;~1.3.0&quot;, &#125;&#125; 依赖包版本格式: 指定：1.2.2 ~+指定：~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2，小于1.3.x） ^ + 指定版本：^1.2.2，表示安装1.x.x的最新版本，（不低于1.2.2，小于2.x.x） latest：最新版本## package.json生成方式： 手写 执行npm init生成依赖包写入package.json不在package.json的包要写入，使用–save 或者–save-dev12npm install express --save # 将该模块写入dependencies属性npm install express --save-dev #将该模块写入devDependencies属性 下载安装、卸载、更新包 安装方式（全局安装与本地安装）123npm install express # 本地安装npm i express #简写npm install express -g # 全局安装 全局安装：安装包放在 /usr/local 下或者你 node 的安装目录，可以在命令行直接使用 本地安装：安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），没有时会自动创建，通过 require() 来引入本地安装的包引用下载的包12//var &lt;Module Name&gt;= require(&apos;&lt;Module Name&gt;&apos;);var express = require(&apos;express&apos;); 卸载包1234npm uninstall express #删除node_modules目录下面的包npm uninstall --save express #删除node_modules的包和package.json中的运行时依赖npm uninstall --save-dev express #删除node_modules的包和package.json中的开发依赖npm uninstall -g express #全局卸载 更新包12npm update expressnpm update express -g # 更细全局包 查询包的信息 查看安装包信息1234npm list #查看本地安装包信息npm list -g #查看全局安装包信息npm list express #查看某个安装包信息npm ls #npm list简写 提升下载包的速度由于npm的包大多是在国外数据库，下载速度会受到影响，我们想快一点，可以使用国内的淘宝镜像。淘宝NPM镜像是一个完成的npmjs.org镜像，基本与官网服务一致。 镜像地址淘宝镜像： 搜索地址：http://npm.taobao.org/ registry地址：http://registry.npm.taobao.org/官网镜像： 搜索地址：https://www.npmjs.com/ registry地址：https://registry.npmjs.org/使用淘宝镜像临时使用淘宝镜像12#安装包时临时制定镜像地址npm --registry https://registry.npm.taobao.org install express 持久使用淘宝镜像先配置npm镜像，然后再安装包配置镜像：12npm config set registry https://registry.npm.taobao.org #设置成淘宝镜像npm config set registry https://registry.npmjs.org/ #设置成官网的 监测是否设置成功12npm config get registry #查询镜像地址npm info express #查询镜像地址 使用cnpm来使用淘宝镜像安装cnpm1npm install -g cnpm --registry=https://registry.npm.taobao.org 使用cnpm安装包1cnpm install [name] 使用nrm来管理切换npm源nrm专门用来管理和快速切换私人配置的registry。 安装1npm install -g nrm 列出可选源1nrm ls 切换源1nrm use taobao 增加源1nrm add &lt;源名称&gt; &lt;源地址&gt; #比如企业或组织有自己的私有源（镜像）时 删除源1nrm del 测试源响应12nrm test #测试所有源nrm test npm #测试npm官方源 如何创建和发布自己的包 创建模块1npm init 此时，生成了package.json配置文件 增加入口文件默认的入口文件是根目录下的index.js，在根目录下创建index.js1234//index.jsexports.printMsg = function() &#123; console.log(&quot;This is a message from the demo package&quot;);&#125; 登录或注册npm账号12npm adduser #注册npm账号npm login #登录npm账号 发布包发布包之前，我们需要做两步： 修改CHANGE.MD，这里记录了我们包发布的版本变化情况，格式自定 修改package.json中的version字段，表示这次发布的包的版本，如果不修改，发布会报错。发布包：1npm publish 撤销发布撤销发布自己发布过的某个版本代码1npm unpublish &lt;package&gt;@&lt;version&gt; 发布成功之后，这个包就可以通过npm install命令来进行安装了。 管理包的版本当我们下载和发布我们的包时，都会关注到包的版本号，npm使用语义版本号来管理包。语义版本号组成：X.Y.Z X代表主版本号，表示有大变动，向下不兼容 Y代表次版本号，表示新增功能，向下兼容 Z代表补丁版本号，表示修复BUG 参考资料：官网：https://www.npmjs.com.cn/getting-started/installing-npm-packages-locally/菜鸟教程：https://www.runoob.com/nodejs/nodejs-npm.htmlnpm脚本使用：http://www.ruanyifeng.com/blog/2016/10/npm_scripts.htmlpackage.json说明：http://javascript.ruanyifeng.com/nodejs/packagejson.html]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli3项目本地mock数据时报404错误]]></title>
    <url>%2F2019%2F05%2F12%2Fvue-cli3-mock-data%2F</url>
    <content type="text"><![CDATA[vue-cli3下创建的项目,在vue.config.js中的devServer开发服务器中的前置中间件mock数据，运行报错的处理。 环境： window7、node.js(11.6.0) 项目： vue-cli3下创建的项目，已安装axios，使用自带的webpack-dev-server来mock数据： 在根目录下创建vue.config.js扩展webpack设置： 在vue组件中获取数据： 查看页面发现报404错误，注意两点： mock配置文件中修改之后需要重启服务，否则不会更新； 如果启动服务过程中检测到代码有错误，但是服务仍然启动成功的，需要解决错误直至错误完全解决，否则会影响配置更新。 在命令行中使用ctrl+C终止服务，重新启动npm start 即可。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>vue-cli3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记git误删的本地文件找回]]></title>
    <url>%2F2019%2F05%2F12%2Fgit-recover-delete-file%2F</url>
    <content type="text"><![CDATA[如何恢复git误删的本地文件？可以使用git reset命令 推送本地代码到github，执行了以下两步：12git add .git commit -m &quot;update blog&quot; 然后一不小心执行了下面的代码1git checkout hexo hexo是要推送的分支，然后，辛辛苦苦写了半天的本地代码就被覆盖了！！！不急不急，找下git历史：执行命令：1git reflog 找到要恢复id，这里我要恢复到我commit的那一刻，执行命令：1git reset --hard 7fe0ee0 这样，代码就找回来了。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli 3.0从零快速创建vue项目原型框架]]></title>
    <url>%2F2019%2F05%2F12%2Fvue-cli3-create-project%2F</url>
    <content type="text"><![CDATA[Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统。下面记录了如何使用Vue CLI 3从零快速创建vue项目原型框架。 环境配置：本机操作系统：window7 安装node.js和npm：node.js(vue-cli 3.0安装需要nodejs版本大于8.9.0，本机安装的是11.6.0) 查看本机node.js版本：1node -v 如果node.js版本低，可以使用一个windows下nodejs的版本管理工具gnvm来更新nodejs版本，可以更新到最新版本，也可以更新到特定版本（文档地址：http://ksria.com/gnvm/），在本机存在nodejs环境时，下载解压缩获取到gnvm.eve后将其保存到nodejs的安装目录下，执行命令更新到最新版本：1gnvm update latest 本机npm版本6.5.0，查看npm版本命令：1npm -v 安装@vue/cli + @vue/cli-service-global：vue-cli3是vue更新的构建工具，降低了使用webpack的难度，支持热更新，有webpack-dev-server支持，搭建了一个测试服务器。（文档地址：https://cli.vuejs.org/zh/guide/）通过 @vue/cli + @vue/cli-service-global 可以快速开始零配置原型开发。 安装命令：123npm install -g @vue-clinpm install -g @vue/cli-service-global 如果已将安装了vue-cli旧版本，需要先卸载就版本，再安装新版本。（官网有说明）安装开发工具Visual Studio Code：Visual Studio Code (简称 VS Code / VSC) 是一款免费开源的现代化轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义快捷键、括号匹配和颜色区分、代码片段、代码对比 Diff、GIT命令 等特性，支持插件扩展，并针对网页开发和云端应用开发做了优化。软件跨平台支持 Win、Mac 以及 Linux。内置Git终端。 下载地址：https://code.visualstudio.com/ 安装成功之后，最好安装一些方便vue开发的插件，在扩展中输入vue，可查询vue相关插件，Vue VSCode Snippets可以提供快速构建代码块命令，安装即可使用快捷命令。 此时，环境已准备好。 创建新项目可以根据使用习惯选择命令行或者UI界面创建新项目： 命令行快速创建新项目：在vscode的下面打开终端，输入创建项目命令：1vue create vue-new 可以使用默认配置（只配置babel 和 eslint）也可以使用自定义配置，通过键盘上下键可切换选择，此时选择自定义配置Manually select features 后按空格键选中/反选自定义配置，按a键 全选/全不选： 仍然是通过键盘上下键选择你要的配置，再通过空格键选择配置，配置说明如下： Bacel：配置Bacel（配置Bacel可以自由的在开发环境使用es6语法，Bacel会将你的es6语句编译为es5语句） TypeScript：配置TypeScript开发环境 Progressive Web App (PWA) Support：配置对PWA的支持（PWA全称Progressive Web App，直译是渐进式WEB应用，是 Google 在 2015 年提出，2016年6月才推广的项目） Router：配置vue router Vuex：配置Vuex CSS Pre-processors：配置css预处理类型 Linter / Formatter：配置Linter / Formatter规范类型 Unit Testing：配置单元测试方式 E2E Testing：配置E2E测试方式 这里选择的自定义配置如下： 选择好回车之后，根据提示输入Y或N ，或者直接回车选择默认配置： 选好配置回车之后，会提示是否保存为之后创建新工程的默认配置： 这里直接回车确认，等待命令完成 此时已经创建好一个新项目。 使用图形化界面创建新项目如果不喜欢在命令行进行操作，也可以在图形化界面创建新项目，在vscode中打开终端，输入命令：1vue ui 可以看到该命令创建了一个本地服务，打开了一个浏览器，窗口如下： 点击创建新项目： 输入项目名，选择包管理器（npm）之后 点击下一步，可以看到，同命令行一样的，进行项目配置： 选择手动配置，点击下一步： 选择自定义配置后点击下一步： 选择具体配置后，点击创建新项目： 保存配置之后，点击创建，看到loading界面，安装成功后，可以看到一个管理页面： 可以在上面管理插件： 配置依赖： 修改配置： 运行和管理任务： 点击运行serve命令，可以看到项目的各项配置，资源和依赖项 点击启动app，可以看到运行起来的页面： 还可以分析项目的打包情况： 此时，创建项目成功。 添加UI库插件如果没有特殊的业务需求或者设计展现，可以根据业务特点，选一款UI库，例如如果是移动端，可以选择滴滴团队的UI框架cube-ui， 输入命令：1vue add cube-ui 项目运行此时可以开始进行开发了。打开项目目录，可以看到项目目录如下： 输入命令运行项目：1npm run serve 可以将此命令改成start， 执行start命令不用输入run：1npm start 此时，已经创建好一个vue项目原型框架，可以尽情地开始开发啦！]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主题个性化配置]]></title>
    <url>%2F2019%2F05%2F11%2Fhexo-next%2F</url>
    <content type="text"><![CDATA[Next是hexo中众多主题之一，在进行hexo博客中各种配置时遇到了不少坑，这里一一记录一下。 修改布局风格 Next默认风格是Muse，可修改为其他，在themes/next/_config.yml中修改配置123456789# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes#scheme: Musescheme: Mist#scheme: Pisces#scheme: Gemini 修改菜单目录 Next主题默认只有主页和和关于，如果要增加菜单，在themes/next/_config.yml中修改配置，1234567891011121314151617# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------menu: home: / || home about: /about/ || user tags: /tags/ || tags #标签 categories: /categories/ || th #分类 archives: /archives/ || archive #归档 guestbook: /guestbook/ || comment #留言 #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons: enable: true 注意，留言页默认是没有的，需要自己增加：1hexo new &quot;guestbook&quot; 效果如下： 添加头像图片 在themes/next/_config.yml中修改配置，1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /uploads/avatar.jpg 图片需要存在目录路径效果如下： 添加社交账号 在themes/next/_config.yml中修改配置，12345678910111213141516171819202122232425# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# Social Links.# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.social: GitHub: https://github.com/yourname || github E-Mail: mailto:yourname@gmail.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skypesocial_icons: enable: true icons_only: false transition: false 效果如下： 添加友情链接 在themes/next/_config.yml中修改配置，12345678# Blog rollslinks_icon: linklinks_title: Linkslinks_layout: block#links_layout: inlinelinks: 简书偶余杭: https://www.jianshu.com/u/8af7f2837baf 效果如下： 添加背景动画 在themes/next/_config.yml中修改配置，这里选了canvas_next，有四种效果，根据自己的喜好选择。（如设置了没有成功，请【1.更新Next主题版本;2.运行命令：hexo clean；hexo g；hexo d】）1234567891011# Canvas-nestcanvas_nest: true# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false 效果如下： 文章字数统计 安装插件： 1npm i --save hexo-wordcount 在themes/next/_config.yml中修改配置， 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true totalcount: true separated_meta: true 打开 post.swig 文件，/themes/next/layout/_macro/post.swig，在对应数字后增加单位：字数：123&lt;span title=&quot;&#123;&#123; __(&apos;post.wordcount&apos;) &#125;&#125;&quot;&gt; &#123;&#123; wordcount(post.content) &#125;&#125; 字&lt;/span&gt; 阅读时长：123&lt;span title=&quot;&#123;&#123; __(&apos;post.min2read&apos;) &#125;&#125;&quot;&gt; &#123;&#123; min2read(post.content) &#125;&#125; 分钟&lt;/span&gt; 效果如下： 增加站内搜索 安装插件：1npm install hexo-generator-search --save 在themes/next/_config.yml中修改配置：12345678910# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 效果如下： 添加版权声明 在themes/next/_config.yml中修改配置： 12345# Declare license on postspost_copyright: enable: true license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/ 效果： 配置页面访问量 使用LeanCloud作为服务后台，先注册一个LeanCloud账号：Leancloud官网创建一个应用，名字随便在应用中的存储中创建一个Class，名字叫做Counter, 权限设置为无限制: 在themes/next/_config.yml中修改配置：123456789# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: app_key: security: false betterPerformance: false 其中 app_id 和 app_key 在 LeanCloud 的设置 -&gt; 应用 Key 可以找到效果如下:记录文章访问量的唯一标识符是文章的发布日期以及文章的标题，因此请确保这两个数值组合的唯一性，如果你更改了这两个数值，会造成文章阅读数值的清零重计 增加评论功能 使用valine+LeanCloud增加评论功能。在themes/next/_config.yml中修改配置：1234567891011121314# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true appid: appkey: notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: 说点什么吧！ # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 注意appid和appkey的名字需要和项目中的valine.swig文件中的配置一致。否则不会加载评论框的哦。这里需要注意，为了安全和valine运行正常，需要在LeanCloud中增加安全域名：效果如下：但是我们又不想所有的页面都有评论，这时候，可以在页面的Front-matter中增加comments: false,就可以不显示评论：123456---title: 关于date: 2018-03-24 22:24:28type: &quot;about&quot;comments: false---]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo小白学习详细教程]]></title>
    <url>%2F2019%2F05%2F11%2Fhexo-cource%2F</url>
    <content type="text"><![CDATA[hexo是一个快速、简介、高效的博客框架，支持Markdown,拥有丰富的插件系统，常与GitHub等代码托管平台一起构建个人博客网站。 hexo是一个快速、简介、高效的博客框架，支持Markdown,拥有丰富的插件系统，常与GitHub等代码托管平台一起构建个人博客网站。 官方链接 中文官网 安装及使用 前提：电脑中需要已安装Git、Node.js(6.9以上) 安装：1$ npm install hexo-cli -g//安装 建站123$ hexo init &lt;目录名&gt;//初始化博客项目（最新版本已经可以在这一步安装依赖）$ cd &lt;目录名&gt;//进入博客$ npm install//安装依赖 命令完成后的目录如下：文件夹说明：123456789101112131415|-- demo//项目跟目录名 |-- .gitignore//git时忽略的文件或目录 |-- package-lock.json |-- package.json//应用程序的信息 |-- _config.yml//网站的配置信息 |-- scaffolds//模板文件夹，Hexo的模板是指在新建的markdown文件中默认填充的内容。 | |-- draft.md | |-- page.md | |-- post.md//博文模板 |-- source//资源文件夹，存放用户资源 | |-- _posts//博文目录 | |-- hello-world.md//博文 |-- themes//主题文件夹，Hexo 会根据主题来生成静态页面 |-- landscape.//默认主题 ... 此时package.json中内容如下：12345678910111213141516171819&#123; &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^3.8.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;, &quot;hexo-server&quot;: &quot;^0.3.3&quot; &#125;&#125; 修改配置：配置修改教程：配置修改配置文件中必须修改的几项，其余可根据配置自行修改： url：网站地址，必须修改，此处博文是托管在github上，故此使用http://youname.github.io格式作为网站名字 language：语言，设置中文，根据需要修改，中文为zh-CN注意：配置值与配置名需要隔一个空格，否则会编译报错123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Hexo小白的博客subtitle:description:keywords:author: Hexo小白language: zh-CNtimezone:# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://emmaHuang.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = &apos;&apos;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &apos;&apos; per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 运行1$ hexo server//运行本地服务 在浏览器打开“http://localhost:4000/”可以看到小站已经建起来了。 使用用hexo进行写博文的命令使用如下： 新建博文1hexo new &quot;my first blog&quot;//有逗号必须使用引号括起来 在source/_posts/下生成文件my-first-blog.md如下：12345---title: my first blogdate: 2019-05-11 16:20:56tags:--- 这里使用---分割的区域叫做“Front-matter”，用于指定这篇博文的变量此时如果运行了hexo server,刷新浏览器时可看到新建的博文：可手动修改Front-matter：123456789101112---layout:title: my first blogdate: 2019-05-11 16:20:56updated:comments:tags:- introduction- hexocategories:- Diary--- tags表示标签， categories表示分类，修改之后刷新如下: 生成静态文件 123hexo generate//简写hexo g hexo g -d//文件生成后立即部署网站hexo g -w//监视文件变动 发表草稿 1hexo publish &quot;my first blog&quot; 启动本地服务器 1hexo server [-p 4001] //可以修改端口 部署网站 123hexo deployhexo d//简写hexo d -g//部署之前先生成静态文件 清除缓存(db.json)和已经生成的静态文件(public)，当发现对站点的更改无效时，比如更换主题后，执行此命令 1hexo clean 列出网站资料 1hexo list 部署hexo提供一键部署的功能，命令：1hexo deploy//简写hexo d 在开始之前，需要安装deployer和在_config.yml中进行配置：安装deployer(这里只记录Git方式)1npm install hexo-deployer-git --save 修改配置1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:emmaHuang1992/emmaHuang1992.github.io.git branch: public message: publish blog 生成站点文件并推送远程库：12hexo clean//清除站点文件hexo deploy//重新生成站点文件并推送 推送之前，在库设置（Repository Settings）中将默认分支设置为_config.yml配置中的分支名称。稍等片刻，站点就会显示Github Pages中 可设置两个分支（根据自己的习惯自行配置）： master：存放源代码 public：存放编译部署后的站点文件 开始在github中新建代码仓库： 新建的repository名字要与账号对应，格式：youname.github.io 生成本机ssh1ssh-keygen -t rsa -C &quot;email@xx.com&quot; 在目标目录中找到id_rsa.pub打开复制内容到github对应库中的settings-&gt;Deploy keys-&gt;Add new-&gt;复制粘贴公钥-&gt;选中确认写入权限-&gt;添加然后执行以下命令： 1234$ eval "$(ssh-agent -s)"$ ssh-add ~/.ssh/id_rsa$ clip &lt; ~/.ssh/id_rsa.pub$ ssh -T git@github.com//测试下公钥有没有添加成功 主题配置 如果不想使用默认的主题，也可以自己下载一个新的主题，放在themes目录下，并修改 _config.yml 内的 theme 设定，即可切换主题。拿使用广泛的next主题为例：next使用教程 在themes目录下克隆next主题 1git clone https://github.com/iissnan/hexo-theme-next themes/next 切换主题 12## Themes: https://hexo.io/themes/theme: next 这时候，重新hexo clean,hexo g，hexo s，就可以看到主题更新啦！]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[换终端使用git分支更新hexo博客]]></title>
    <url>%2F2019%2F05%2F11%2FchangeBlog%2F</url>
    <content type="text"><![CDATA[这些天想更新之前使用hexo搭建的博客，发现换终端之后需要重新安装环境，这里记录了如何使用git分支在换终端之后更新hexo博客。 #这是换机之前的操作：先把源文件上传git分支由于由hexo d编译部署上传到github上的不是源文件，是编译之后生成的网页：即我们编译生成的.deploy_git里面的内容：而我们需要的源文件目录是包括source、themes、package等文件的目录： 所以我们需要把源文件目录也上传到github上，从而进行管理，首先，在你的博客Repository中新建一个“hexo”分支，名字自定：然后在setting中设置默认分支为hexo，便于推送： 这时候，新建目录，在目录下运行命令：1git clone https://github.com/huanglcat/huanglcat.github.io.git 把源文件分支克隆到本地，注意，克隆时只会克隆默认分支的内容，如果默认分支不是hexo，就没有克隆到源文件。 克隆下来的文件目录如下： 把除了.git 文件夹外的所有文件都删掉（这些是编译后的网页文件），把之前我们写的博客源文件全部复制过来，除了.deploy_git（编译后的文件目录）。其中，.gitignore（设置不需要git的文件或目录）文件中中需要设置部分不需要上传的目录： 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ git不能嵌套上传，由于我之前克隆过主题，在主题中有一个.git目录：把它删掉，否则在其他终端下载时会报错。 这时候，在根目录下运行命令：123git add .git commit –m &quot;add branch&quot;git push 查看是否正确更新： #换终端的操作git、npm、node.js等环境先安装好，设置全局用户：12git config --global user.name &quot;yourgithubname&quot;git config --global user.email &quot;yourgithubemail&quot; 生成本机 ssh key1ssh-keygen -t rsa -C &quot;youremail&quot; 生成后增加在github库中。安装hexo：1npm install hexo-cli -g 同样克隆下分支之后，安装依赖库12npm installnpm install hexo-deployer-git --save 生成和部署博客：12hexo ghexo d 就可以更新博客了。]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记Github+hexo搭建个人博客]]></title>
    <url>%2F2018%2F03%2F25%2Fblog%2F</url>
    <content type="text"><![CDATA[2018年初，想要重新建博客，于是用Github+hexo搭建了本博客。使用hexo本地搭建页面，再push到Github仓库。本文记录了使用Github+hexo搭建个人博客的过程及遇到的问题。 环境 window系统 已安装git 已安装Node.js 准备hexo安装hexo1$ npm i hexo-cli -g 检查hexo是否安装成功 1$ hexo 提示找不到命令，于是增加环境变量，为hexo安装路径的bin目录：之后成功响应。 初始化hexo新建一个空文件夹，我命名为hexo，进入hexo目录，打开git Bash，初始化hexo1$ hexo init 生成项目目录如下： 安装hexo插件1$ npm i hexo-deployer-git --save 安装过程中出现问题：出现这个问题可能是由于npm cache,于是对npm cache进行清理：1$ npm cache clean --force 之后正常安装。 使用hexo此时可以创建页面了1$ hexo g # hexo generate 成功生成页面后，进行本地预览1$ hexo s # hexo server 看到以下画面，说明本地页面搭建成功 需要新建一个文章时输入命令：1$ hexo new “name” 需要在项目的source目录下新建一个页面时输入命令：1$ hexo new page “name” 当重新编辑页面时，在本地调试12$ hexo g #当修改配置时，需要执行这一步$ hexo s --debug 推送上Github命令1$ hexo d # hexo deploy 清除缓存1$ hexo clean 增加图片 需要在文章中增加图片时，可以直接插入html代码，也可以使用MarkDown语法： 图片存在根目录source下的imgs目录，也可使用外链 12&lt;img src=&quot;/imgs/index.png&quot; width = &quot;800&quot; height = &quot;200&quot; alt=&quot;图片名称&quot; align=center /&gt; ![“图片描述”](/imgs/你的图片名字.JPG) hexo详细命令查看: hexo api 准备Github准备repository新建的repository名字要与账号对应，格式：huanglcat.github.io 设置SSH这时需要将Github连接本地，设置SSH。设置SSH有多种方法，我使用了git命令来生成秘钥，首先在本地创建SSH KEYS（邮箱为github注册邮箱，之后要去确认路径和输入密码，一路回车就可以）： 1$ ssh-keygen -t rsa -C "email@xx.com" 成功的话会在 ~/下生成 .ssh文件夹，进去(设置的SSH可以在c盘中的用户目录中找到)，打开 id_rsa.pub，复制里面的key粘贴到setting中的key输入框中。输入 eval &quot;$(ssh-agent -s)&quot; ，添加密钥到ssh-agent，再输入 ssh-add ~/.ssh/id_rsa ，添加生成的SSH key到ssh-agent 1234$ eval "$(ssh-agent -s)"$ ssh-add ~/.ssh/id_rsa$ clip &lt; ~/.ssh/id_rsa.pub$ ssh -T git@github.com//测试下公钥有没有添加成功 出现“you`re successfully authenticated”即设置成功 修改配置修改hexo配置修改项目根目录下的“_config.yml”文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Emma的博客 # titlesubtitle:description: 桌上有刀，桌下有猫 #网站描述keywords:author: Emma language: zh-Hanstimezone:# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://huanglcat.github.io #注意修改此处链接root: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = &apos;&apos;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &apos;&apos; per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: # 注意修改deploy type: git repo: git@github.com:huanglcat/huanglcat.github.io.git branch: master 注意：配置文档的冒号“：”后必须要有一个空格，否则会报错 push到Github首先配置git12$ git config --global user.email "emai@xxx.com"$ git congif --global user.name "huanglcat" 然后执行以下命令12$ hexo g $ hexo d 在浏览器查看：huanglcat.github.com，可以看到一个hexo默认主题的页面（当看到404时，试试清除缓存） 修改主题更换主题首先将看好的主题克隆下来， 1$ git clone https://github.com/theme-next/hexo-theme-next themes/next 然后修改项目根目录下的”_config.yml” 1theme: next 这时主题已经更换为next了，而next主题中有几种外观可以更换，找到根目录下的themes下的next主题目录，在其中的“_config.yml”配置文件中修改： 123456# Schemesscheme: Mist#scheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 修改目录当前目录只有首页和归档，next中可以增加目录，在next主题的“_config.yml”中修改： 123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 注意，除了home和archives,其他目录都需要自己创建页面： 1$ hexo new page “tags” 创建之后页面在项目根目录的source目录下生成，之后还需修改页面类型： 12345---title: 标签date: 2018-03-24 22:19:58type: &quot;tags&quot;--- 增加头像在主题中增加头像，可以使用本地增加图片也可以用外链。在本地增加先在next目录的source目录下新建文件夹“uploads”，增加图片；在next主题的“_config.yml”中修改： 1avatar: /uploads/avatar.jpg 首页折叠此时，博客首页的文章是全部显示的，需要将文章进行折叠，在文章需要折叠的内容之前增加代码 1&lt;!--more--&gt; 此时首页文章已经折叠了： 参考： hexo使用：https://hexo.io/ 设置SSH：http://www.xuanfengge.com/using-ssh-key-link-github-photo-tour.html MarkDown使用：https://www.appinn.com/markdown/ 更换主题：https://segmentfault.com/a/1190000012805627 修改主题：http://theme-next.iissnan.com/getting-started.html 增加图片：https://segmentfault.com/a/1190000009478837]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
</search>
